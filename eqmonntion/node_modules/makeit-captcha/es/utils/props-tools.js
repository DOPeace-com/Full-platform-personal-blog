var _this = this;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _newArrowCheck(innerThis, boundThis) { if (innerThis !== boundThis) { throw new TypeError("Cannot instantiate an arrow function"); } }

import { isVNode, Fragment, Comment, Text } from 'vue';
import { $tools } from '../utils/tools';
export var tuple = function tuple() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args;
};
var onRE = /^on[^a-z]/;

var isOn = function isOn(key) {
  _newArrowCheck(this, _this);

  return onRE.test(key);
}.bind(this);

var splitAttrs = function splitAttrs(attrs) {
  _newArrowCheck(this, _this);

  var allAttrs = Object.keys(attrs);
  var eventAttrs = {};
  var onEvents = {};
  var extraAttrs = {};

  for (var i = 0, l = allAttrs.length; i < l; i++) {
    var key = allAttrs[i];

    if (isOn(key)) {
      eventAttrs[key[2].toLowerCase() + key.slice(3)] = attrs[key];
      onEvents[key] = attrs[key];
    } else {
      extraAttrs[key] = attrs[key];
    }
  }

  return {
    onEvents: onEvents,
    events: eventAttrs,
    extraAttrs: extraAttrs
  };
}.bind(this);

var getEvents = function getEvents() {
  var ele = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var on = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var props = {};

  if (ele.$) {
    props = _objectSpread(_objectSpread({}, props), ele.$attrs);
  } else {
    props = _objectSpread(_objectSpread({}, props), ele.props);
  }

  return splitAttrs(props)[on ? 'onEvents' : 'events'];
};

var isEmptyElement = function isEmptyElement(elem) {
  _newArrowCheck(this, _this);

  return elem.type === Comment || elem.type === Fragment && elem.children.length === 0 || elem.type === Text && elem.children.trim() == '';
}.bind(this);

var flattenChildren = function flattenChildren() {
  var _this2 = this;

  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  children = Array.isArray(children) ? children : [children];
  var res = [];
  children.forEach(function (child) {
    _newArrowCheck(this, _this2);

    if (Array.isArray(child)) {
      res.push.apply(res, _toConsumableArray(flattenChildren(child)));
    } else if (child && child.type === Fragment) {
      res.push.apply(res, _toConsumableArray(flattenChildren(child.children)));
    } else if (child && isVNode(child) && !isEmptyElement(child)) {
      res.push(child);
    } else if ($tools.isValid(child)) {
      res.push(child);
    }
  }.bind(this));
  return res;
};

var getSlot = function getSlot(instance) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (isVNode(instance)) {
    if (instance.type === Fragment) {
      return name === 'default' ? flattenChildren(instance.children) : [];
    } else if (instance.children && instance.children[name]) {
      return flattenChildren(instance.children[name](options));
    } else {
      return [];
    }
  } else {
    var res = instance.$slots[name] && instance.$slots[name](options);
    return flattenChildren(res);
  }
};

var getSlotContent = function getSlotContent(instance) {
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : instance;
  var exec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var content = undefined;

  if (instance.$) {
    var temp = instance[prop];

    if (temp !== undefined) {
      return typeof temp === 'function' && exec ? temp(options) : temp;
    } else {
      content = instance.$slots[prop];
      content = content && exec ? content(options) : content;
    }
  } else if (isVNode(instance)) {
    var _temp = instance.props && instance.props[prop];

    if (_temp !== undefined && instance.props !== null) {
      return typeof _temp === 'function' && exec ? _temp(options) : _temp;
    } else if (instance.type === Fragment) {
      content = instance.children;
    } else if (instance.children && instance.children[prop]) {
      content = instance.children[prop];
      content = content && exec ? content(options) : content;
    }
  }

  if (Array.isArray(content)) {
    content = flattenChildren(content);
    content = content.length === 1 ? content[0] : content;
    content = content.length === 0 ? undefined : content;
  }

  return content;
};

var getPropSlot = function getPropSlot(slots, props) {
  var _props$prop, _slots$prop;

  var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
  return (_props$prop = props[prop]) !== null && _props$prop !== void 0 ? _props$prop : (_slots$prop = slots[prop]) === null || _slots$prop === void 0 ? void 0 : _slots$prop.call(slots);
};

var getPrefixCls = function getPrefixCls(suffixCls, prefixCls, customizeCls) {
  _newArrowCheck(this, _this);

  if (customizeCls) return customizeCls;
  return "".concat(prefixCls !== null && prefixCls !== void 0 ? prefixCls : 'mi', "-").concat(suffixCls);
}.bind(this);

var initProps = function initProps(types, defaultProps) {
  var _this3 = this;

  _newArrowCheck(this, _this);

  var propTypes = _objectSpread({}, types);

  Object.keys(defaultProps).forEach(function (k) {
    _newArrowCheck(this, _this3);

    var prop = propTypes[k];

    if (prop) {
      if (prop.type || prop.default) {
        prop.default = defaultProps[k];
      } else if (prop.def) {
        prop.def(defaultProps);
      } else propTypes[k] = {
        type: prop,
        default: defaultProps[k]
      };
    } else {
      throw new Error("".concat(k, " prop does not exist."));
    }
  }.bind(this));
  return propTypes;
}.bind(this);

export { splitAttrs, getEvents, isEmptyElement, flattenChildren, getSlot, getSlotContent, getPropSlot, getPrefixCls, initProps };